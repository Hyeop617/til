0718 Today I Learned.



## Socket

소켓 프로그래밍을 구현할 일이 생겼다.<br>
문제는 이때까지 소켓을 제대로 해본적이 없기에 정리를 해보고자 한다.

소켓은 일반적인 HTTP 통신과는 다르다.<br>

먼저 HTTP 통신은 요청 - 응답이 각각 한 번하면 끝나는 구조다.<br>
그래서 실시간 통신을 위해서 Polling이라고, 일정 시간마다 주기적으로 요청 - 응답을 주고받거나, <br>
Long polling이라고 서버가 응답을 줄때까지 클라이언트가 대기하는 방식도 생겼다.

하지만 HTTP 통신은 HTTP 헤더의 크기가 크기 때문에,  <br>
(크롬 개발자모드에서 확인해보면 무수히 많은 헤더가 보일것이다.). <br>
채팅같은 것을 생각해보면 body(payload)보다 header의 크기가 훨씬 커질수도 있는 것이다.

예를 들면 body가 'hi'라는 2 바이트라고 가정해보자.  <br>
HTTP 통신이라면 서버 설정에 따라 다르겠지만, 일반적으로 Content-Type, CORS 관련 헤더, X-Forwared-IP 등등의 여러 헤더가 같이 갈 것이다.  <br>
정작 중요한 알맹이는 2 바이튼데, 헤더는 바디에 비해 엄청나게 비대해 질 것이다. 특히 쿠키가 많아지면 엄청나게 늘어날 것이다.  <br>
[GeeksforGeeks](https://www.geeksforgeeks.org/what-is-web-socket-and-how-it-is-different-from-the-http/)에 따르면 보통 헤더가 700~800바이트를 차지한다고 하는데..  <br>
어쩔수 없다는 것을 알지만, 꾸준히 서버와 클라이언트가 통신하기에 효율적이지는 않아 보인다.

그리고 Polling을 사용한다고 쳐도 연결을 계속 다시 하는 구조 (요청 - 응답 - 응답이 불가능하다.)이기 때문에,  <br>
클라이언트는 서버에게 계속 요청을 날려야하기 때문에 불필요한 통신이 늘어날 것이다.  

따라서 이런 Polling의 단점을 해결하기 위해 Streaming이라는 HTTP 통신 방법이 새로 나왔다. (HTTP Live Streaming, HLS라고 불리는것 같다). <br>
이름에서 알 수 있듯 동영상 스트리밍을 생각하면 쉽다.

유튜브를 볼때 동영상 전체를 로딩한 뒤 보지는 않는다.  <br>
동영상을 쪼개서 조금씩 조금씩 로딩 하는 것을 모두 알고 있을 것이다.  <br>
이 규약을 이용하면, 요청 - 응답 - 응답 - ... 이 가능하다. 즉 요청을 한 번 날렸지만, 꾸준히 응답을 받는 것이 가능하다.  

하지만 HLS가 모든 것을 해결해주진 않는다.  <br>
요청과 응답의 관계에서 알다시피 요청이 있어야 응답이 있다. 요청이 없는 응답은 말이 안된다.  <br>
또한 요청을 했는데 응답이 없으면 이것 또한 말이 안된다.  

그래서 HTML5 환경에서는 Socket이라는 통신 규약이 새로 나왔다.

Socket에 대해서 살펴보자.

onOpen : 소켓이 연결될때 실행되는 이벤트.<br>
onClose: 소켓의 연결이 끊길 때 실행되는 이벤트. <br>
onMessage : 소켓에 메시지가 도착할때 실행되는 이벤트. <br>
onError: 소켓 에러가 발생할때 실행되는 이벤트. 

이벤트는 이렇게 4개가 있고, 당연히 메시지를 보내는 것 (send)도 있을테니. <br>
크게 5가지 경우를 생각하면 될 것같다.  

소켓은 String과 Byte밖에 전송이 안된다고 한다.<br>
따라서 현재의 구조를 살펴보니 Object를 JSON으로 파싱해서 보내는 구조로 하고 있었다.

문제는 이미지는 현재 REST API로 따로 업로드하고 있는데.. (클라 -> 서버)<br>
아마 서버 -> 클라로 이미지를 전송해야 할때는<br>
잠깐 든 생각이지만..

1. 이미지를 base64 인코딩해서 String으로 보내는 방법<br>
   {type: 'image', data: 'data:image/png;base64:~~~' }
2. 서버에서 클라우드로 이미지를 업로드 후에,<br>
   클라우드의 이미지 주소를 소켓으로 전송하는 방법<br>
   {type: 'image', data:'https://image.url/10230123/}

이렇게 두가지 방법이 생각이 난다.<br>
Base64 인코딩은 처리도 귀찮고 용량도 늘어나고... 개인적으로 선호하진 않는데..<br>
클라우드로 업로드해서 URL 던져주는 건 편법같은 느낌도 세게 들고.. 정답은 없겠지만,

1번을 사용하면 서버->클라, 클라->서버가 같은 방식이라 유지보수가 편하고 (물론 FE, BE 개발자가 다르면 상관 없을수도?)<br>
2번은 IO처리를 안해서 편하지만 이미지 전송을 위해 이미지 업로드를 하는 방식이라 이상하긴 하다.<br>
적어놓고 보니 1번이 맞는 것 같다. 2번은 이렇게도 된다 수준..?

남들은 학부때 배우는 걸 이제와서 배우니 난 학부때 뭐했나 싶다..
