## 220502 - Gradle Multi Module

Gradle Multi Module에 대해서 좀 더 **자세히** 알아보고자 한다.

일단 그래들 멀티 모듈 자체로만 놓고보면 단점보다는 장점이 많은 것 같다.
그 장점에 대해서 모놀리식과 잘 비교를 해야 할 것 같다... **정말로 잘.**
아무래도 MSA도 모놀리식도 아닌 애매한 중간 포지션인 것 같기 때문에, 헷갈릴 수 있는 부분이 많다고 느꼈다.



어드민 프로젝트, B2C 프로젝트, B2B 프로젝트가 있다고 하자.
User Entity에 nickname 필드가 추가되었다! nation 이라는 필드도 추가되었다!
해당 필드들을 추가하고 수정이 끝났다고 치자.
앞으로 유저이름 뒤에 nation 필드를 붙여서 화면에 뿌려줘야 한다고 하네?
또 세 프로젝트 모두 수정..
(반복)

같은 코드를 수정하기 위해 여러 군데를 봐야하고, 그러다 깜빡하는 경우도 분명 생길것이다.
공통으로 사용하는 라이브러리도 있는데 이게 버전업을 하거나 다른 라이브러리로 교체가 될 수도 있을 것이다.



이런 부분을 모듈로 쪼개보자.

![nowadays.png](https://techblog.woowahan.com/wp-content/uploads/img/2019-07-01/failed-project.png)

(현재 개인적으로 프로젝트에서 사용하는 멀티 모듈 구조)
일단 common이라는 모듈을 사용을 했다. 이런식으로 멀티 모듈을 구성하면 어떤 장점이 있을까?



1. 중복되는 코드가 줄어듬.
   - Admin과 B2C, B2B 등 다양한 프로젝트에서 동일한 로직을 사용하는 곳이 있을 때,
     이 로직을 각각 프로젝트마다 모두 따로 구현해야한다면? 거기에 수정도 잦다면?
2. 재사용성이 증가
   - 각 모듈은 독립적이고 필요한 최소한의 의존성만 갖고 있기 때문에 결합도가 낮다.
   - 필요한 모듈끼리만 조합해서 사용하면 된다.
3. 변경이나 수정이 자유롭다.
   - 해당 모듈만 변경하고 수정하면 된다.
   - 각 모듈간에 책임을 분리했기 때문에.

4. 독립적인 실행 가능

   - 모듈 별로 따로따로 배포가 가능하다. 모놀리식도 그렇지 않냐고? 일단 빌드 시간이 줄어든다.

   - 분리를 하면 원하는 부분만 떼서 실행이 가능하다. 코드 간 의존성을 피할 수 있다.

   - Redis 모듈을 있다고 하면, Redis를 사용하는 서비스에서만 해당 모듈을 포함하면 된다.



모두 무시할 수 없는 장점들이다.

그래서 common 모듈을 이용한 멀티 모듈 구조를 사용하였다.
그렇게 개발하던 중 확장성의 한계를 점점 느끼고 있었다.
(어드민에서는 redis를 사용안하는데 다른 모듈들에서 redis를 사용하니 common에 레디스가 들어가고..)


**모듈을 분리할 때엔 모듈간의 책임을 명확히 분리지어야 한다.**

명확히 분리하지 않고, 현재는 다 공통으로 쓰니까 공통 모듈에 때려박다보면 나중에 확장하기 곤란한 경우가 생긴다. (**정말로**)
(위의 구조를 배민 블로그에선 common의 저주라고 부르더라..)

아직까지 모듈을 분리하는 정답은 없는 것 같지만, 배민 블로그에 나온 모듈 분리 방법이 정답에 가깝지 않나라고 생각한다.



#### 배달의민족 기술 블로그 멀티 모듈 구성

![배민 예시.png](https://techblog.woowahan.com/wp-content/uploads/img/2019-07-01/modules.png)

Independently Available - **독립 모듈 계층**
현재 프로젝트에 묶여 있지 않은 모듈. 자체 제작한 라이브러리 등이나, 다른 프로젝트에서도 충분히 사용이 가능한 모듈

System Core - **공통 모듈 계층**
다른 외부 의존 관계를 갖지 않고 (Gradle dependency가 없음) 순수한 Type이나 Util 등만 정의.
즉 각 모듈간에 서로 필요한 Java Beans만 최소한으로 갖고 있는 모듈.

System Domain - **도메인 모듈 계층**
저장소와 밀접한 중심 도메인. 해당 계층은 다음 원칙을 따름.

- 서비스 비즈니스를 모른다.
- 하나의 모듈은 최대 하나의 인프라스트럭쳐에 대한 책임만 갖는다.
- 도메인 모듈을 조합한 더 큰 단위의 도메인 모듈이 있을 수 있다.

예시를 보자.

![single_infrastructure.png](https://techblog.woowahan.com/wp-content/uploads/img/2019-07-01/domain-layer.png)

단일 인프라스트럭쳐 모듈의 예시다.
도메인 모듈은 Domain, Repository, Service를 갖는다.
그럼 애플리케이션 모듈도 Repository와 Service를 갖는데 어떤 차이가 있냐?

Domain Module 내의 Repository는 모든 CRUD를 책임지지 않는다.
특정한 기능이 도메인과 더 밀접한 기능인지, 비즈니스와 더 밀접한 기능인지 (도메인과 밀접하지 않은지)를 따져봐야한다. 
예를 들어 유저를 저장하는 코드는 Domain Module 쪽에 가까울테고, 특정 시기 가입한 유저의 수를 찾는 코드는 Application Module에 더 가까울 것이다.

Service또한 마찬가지다. Domain Module 내의 Service는 **도메인의 비즈니스**를 책임진다.
따라서 도메인의 비즈니스가 단순하다면 생기지 않을 수도 있다.
(배민 기술블로그의 저자께선 트랜잭션의 단위를 정의하고, 요청 데이터를 검증하고, 이벤트를 발생시키는 등 도메인의 비즈니스를 작성하셨다고 한다.)

(직관적으로 해당 로직이 도메인과 논리적인 관계가 얼마나 가까운지를 따져보면 될 것 같다. 정답은 없는 듯..?)



더 큰 단위의 도메인 모듈의 예시다

![multi_infra.png](https://techblog.woowahan.com/wp-content/uploads/img/2019-07-01/multi-infra.png)

도메인 모듈이 MySQL을 사용하고 있다 쳐보자. 여기서 Redis 의존성을 추가하면 왼쪽 그림이 될 것이다.
하지만 어드민 애플리케이션은 Redis가 필요하지 않는 상황이라면 해당 구조는 명확하게 책임이 분리되어있다고 보기 어렵다.
**앞에서 말한 common의 저주가 다시 시작 될 것이다.**
(어드민에서 redis 설정 없다고 안 뜰테고.. 그렇다고 yml profile로 관리하자니 찝찝하고..)

이럴 때 도메인 모듈을 서로 분리하고, 그 도메인 모듈을 필요하면 묶는 식으로 구성하면 오른쪽 그림일 것이다.
어드민에서는 필요하지 않은 Redis 의존성을 갖고 있지 않다.



![in_system_available.png](https://techblog.woowahan.com/wp-content/uploads/img/2019-07-01/dependency-relation3.png)

In System Available - **내부 모듈 계층**
시스템과 연관이 있는 모듈. 해당 계층은 다음 원칙을 따른다.

- 어플리케이션, 도메인 비즈니스를 모른다.

시스템 전체적인 기능을 서포트하기 위한 모듈이 만들어질 수 있다.
이 계층 역시 프로젝트 안의 어떠한 실행 가능한 애플리케이션에서도 독립으로 사용 가능한 모듈이어야 하므로, 도메인 계층을 의존하지 않는다.

*응? 이게 무슨소리지...?*

시스템을 서포트하지만 도메인과 비즈니스를 몰라야하는 애매한(?) 모듈이다.
자바 빈즈가 들어있는 것도 아니고.. 대체 무슨 모듈이지?
배민 기술블로그에서 사용하는 것을 보고 해당 모듈의 역할을 알 수 있었다.



**core-web**

> web 설정을 사용하는 프로젝트에서 사용할 수 있는 모듈이다. 주로 Web Filter 를 이용한 보안, 로깅 등으로 활용되며, 웹에 대한 필수적인 공통 설정을 하기도 한다.

**xxx-client**

> 외부의 xxx 시스템과 통신을 책임지는 모듈이며 각 외부 시스템별로 따로 모듈을 만들었습니다. 이 모듈은 비지니스와 관계없이 요청과 응답을 할 수 있는 사용성을 제공하고, 요청에 대한 설렁과 스팩을 책임집니다. 어플리케이션 모듈에서는 사용하는 외부 시스템 모듈만 사용하게 됩니다.

**xxx-event-publisher**

> 특정 이벤트에 대한 처리를 담당합니다. 여기서 말하는 이벤트는 Spring ApplicationEvent 를 말하며, 이벤트가 발생했을 때 `SQS` 로 이벤트를 전송하거나, 로그를 남기는 등 특정 행위를 처리합니다. 이 모듈 또한 하고 있는 주요 행위의 범위에 따라 따로 모듈이 생성될 수 있습니다.

공통적인 시큐리티 설정이나 RestTemplate 혹은 WebClient 같은 빈, Publisher 등이 존재하는 모듈이다.
이런 책임이면 확실히 모듈별로 분리해 놓는게 이점이 있을 것 같다.





![applicaiton_module.png](https://techblog.woowahan.com/wp-content/uploads/img/2019-07-01/dependency-relation5.png)

Application - **애플리케이션 모듈**

비즈니스 모듈도 갖고 있으며, 앞서 말했던 모듈들을 조합시켜 하나의 애플리케이션을 구동하는 모듈 (bootJar)





의존성을 왜 최소화 해야할까? 배민 기술블로그의 글에는 이렇게 적혀있다.

> 자바에서 성능적으로 본다면 사실 그렇게 큰 성능 차이는 아닐 것 입니다. 그러나 좋은 개발환경이란 측면과 `Spring Boot` 를 사용하는 측면에서는 손해를 볼 수 있습니다. 여러가지 손해들이 있겠지만 아래 두 가지를 짚어보았습니다.
>
> **첫번째로는 여지의 개방으로 개발 생산성을 떨어트립니다.** 무엇이든 끌어다쓸 수 있게 된다는 측면에서는 초기에는 빠르게 개발을 할 수도 있지만, 그로인해 만들어지는 스파게티 의존으로 점차 개발 생산성이 떨어지게 됩니다.
>
> **두번째로 `Spring Boot` 를 사용하고 있기 때문에 예상치 못했거나, 불필요한 설정이 동작하게 될 수 있습니다.** `Spring Boot` 는 Class 의 존재만으로도 작동되는 설정들이 아주 많이 있습니다.

점점 의존성이 강해지면 나중에 분리하기 힘들어진다. 말 그대로 초기에는 빠르게 개발할 수 있으나, 언젠가 한계에 부딪힐 것이다.
두 번째 경우는 모듈간 분리가 제대로 안 되어있을 때의 커먼의 저주를 뜻하는 것 같다. 확실히 불필요한 설정이 동작하거나 필요해진다...





오케이 그럼 이렇게 하면 단점은 없는 것일까?

일단 위의 구성을 보더라도 학습 곡선이 낮진 않을 것 같다. 각 모듈 별로 책임을 산정하는데 시행착오를 많이 겪겠지..
또한 같이 일하는 팀 모두 저 모듈 구조를 이해해야한다. 팀원들 모두의 동의가 필요하다.

위와 같은 단점도 무시할 수 없다고 생각한다. 그리고 멀티 모듈의 단점은 아니겠지만 중요한 것은

저런 구조로 가게 되면 결국 MSA를 잘 알고 있어야 한다는 것이다.
**MSA를 모른 채로 저렇게 구성하면 결국 MSA의 단점이 프로젝트에 추가가 된다!!**

내가 느끼기엔 멀티 모듈은 MSA를 하기 위한 그래들 내 한 가지 기술? 접근법? 이라고 생각한다.
그래도 MSA를 하기 위해 피할 수는 없는 방법이니 여기서 마무리하자.

